__d(function (global, _require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

  var _reactNative = _require(_dependencyMap[0], "react-native");

  var _ActionTypes = _require(_dependencyMap[1], "../../actions/ActionTypes");

  var actions = _interopRequireWildcard(_ActionTypes);

  var _coins = _require(_dependencyMap[2], "../../constants/data/json/coins.json");

  var _coins2 = _interopRequireDefault(_coins);

  var _tokens = _require(_dependencyMap[3], "../../constants/data/json/tokens.json");

  var _tokens2 = _interopRequireDefault(_tokens);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

  function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

  var INITIAL_STATE = {
    newWallet: false,
    walletName: '',
    tokens: [],
    wallet: null,
    backupPassphrase: '',
    coinData: _coins2.default,
    QrData: '',
    QrScannerInvoker: '',
    current_token: {},
    debugMode: false,
    txnFee: 0,
    newTokenName: '',
    newTokenAddress: '',
    allTokens: _tokens2.default[0]
  };

  exports.default = function () {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : INITIAL_STATE;
    var action = arguments[1];

    switch (action.type) {
      case actions.QRSCANNER_DATA:
        return _extends({}, state, {
          QrData: action.payload
        });

      case actions.CREATING_NEW_WALLET:
        return _extends({}, state, {
          newWallet: true,
          wallet: action.payload
        });

      case actions.NEW_WALLET_NAME:
        return _extends({}, state, {
          walletName: action.payload
        });

      case actions.ADD_TOKEN_SETUP:
        var current = state.tokens;

        var selectedToken = _extends({}, action.payload, {
          balance: 0
        });

        var newTokens = [];
        var index = current.map(function (token) {
          return token.id;
        }).indexOf(action.payload.id);

        if (index === -1) {
          newTokens = [].concat(_toConsumableArray(current), [selectedToken]);
        } else {
          newTokens = [].concat(_toConsumableArray(current.slice(0, index)), _toConsumableArray(current.slice(index + 1)));
        }

        return _extends({}, state, {
          tokens: newTokens
        });

      case actions.ADD_TOKEN_INFO:
        return _extends({}, state, {
          current_token: action.payload
        });

      case actions.DEBUG_MODE:
        return _extends({}, state, {
          debugMode: true
        });

      case actions.UPDATE_TOKEN_BALANCE:
        var token = state.tokens[action.payload.tokenID];

        var updatedToken = _extends({}, token, {
          balance: action.payload.balance
        });

        var previousTokens = state.tokens;
        previousTokens[action.payload.tokenID] = updatedToken;
        return _extends({}, state, {
          tokens: previousTokens
        });

      case actions.TXN_FEE:
        return _extends({}, state, {
          txnFee: action.payload
        });

      case actions.ADD_NEW_TOKEN_ADDRESS:
        return _extends({}, state, {
          newTokenAddress: action.payload
        });

      case actions.ADD_NEW_TOKEN_NAME:
        return _extends({}, state, {
          newTokenName: action.payload
        });

      case actions.COMPLETE_NEW_TOKEN:
        var lastID = state.tokens[state.tokens.length - 1].id + 1;
        var coinObj = {
          "id": lastID,
          "type": "ERC20",
          "selected": true,
          "symbol": state.newTokenName,
          "address": state.newTokenAddress,
          "decimals": 18,
          "name": state.newTokenName,
          "ens_address": "",
          "website": "",
          "logo": {
            "src": "https://etherscan.io/token/images/binance_28.png",
            "width": 28,
            "height": 28,
            "ipfs_hash": ""
          },
          "support": {
            "email": "",
            "url": ""
          },
          "social": {
            "blog": "",
            "chat": "",
            "facebook": "",
            "forum": "",
            "github": "",
            "gitter": "",
            "instagram": "",
            "linkedin": "",
            "reddit": "",
            "slack": "",
            "telegram": "",
            "twitter": "",
            "youtube": ""
          }
        };
        var oldTokens = state.tokens;
        oldTokens.push(coinObj);
        var oldcoinData = state.coinData;
        oldcoinData.push(coinObj);
        return _extends({}, state, {
          coinData: oldcoinData,
          tokens: oldTokens,
          newTokenAddress: '',
          newTokenName: ''
        });

      case actions.ADD_TOKEN_FROM_LIST:
        var lastIDcheck = state.tokens[state.tokens.length - 1].id + 1;
        var NewcoinObj = {
          "id": lastIDcheck,
          "type": "ERC20",
          "selected": true,
          "symbol": action.payload[name],
          "address": action.payload[add],
          "decimals": 18,
          "name": "New Token",
          "ens_address": "",
          "website": "",
          "logo": {
            "src": "https://etherscan.io/token/images/binance_28.png",
            "width": 28,
            "height": 28,
            "ipfs_hash": ""
          },
          "support": {
            "email": "",
            "url": ""
          },
          "social": {
            "blog": "",
            "chat": "",
            "facebook": "",
            "forum": "",
            "github": "",
            "gitter": "",
            "instagram": "",
            "linkedin": "",
            "reddit": "",
            "slack": "",
            "telegram": "",
            "twitter": "",
            "youtube": ""
          }
        };
        var OldTokens = state.tokens;
        OldTokens.push(NewcoinObj);
        var OldcoinData = state.coinData;
        OldcoinData.push(NewcoinObj);
        return _extends({}, state, {
          coinData: OldcoinData,
          tokens: OldTokens
        });

      default:
        return state;
    }
  };
});